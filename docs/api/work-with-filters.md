# Як працювати з фільтрами

Запит по фільтрам має формат: `v2/filter/{filter}`

Method: `GET`

## Request

`{filter}` - це набір параметрів по якому буде відбуватись фільтрація. Формат

`{filter group 1}={filter slugs from group 1 separated by comma}/{filter group 2}={filter slugs from group 2 separated by comma}`

Example: `v2/filter/taste=miatni,solodki/goods=syrop-makadamiia,syr-salers`

```bash
curl https://api.mixdrinks.org/v2/filter/taste=miatni,solodki/goods=syrop-makadamiia,syr-salers
```

## Відповідь від сервера

- totalCount - загальна кількість коктейлів що задовільняють фільтр
- cocktails - одна сторінка коктейлів (про розмір сторінки можна взнати [тут](paggination.md))
- descriptions - SEO опис що відповідає фільтру
- futureCounts - інформація про майбутні можливі фільтри. Структура `id групи`:`id фільтра`:`інфомація про фільтр`
- isActive - показує чи вибраний зараз цей фільтр, вираховується на backend на основі запиту від клієнта

В інформації про фільтр є кількість коктейлів які поверне сервіс якщо вибрати цей фільтр, також є query яке треба
передати серверу
в якості параметра `{filter}` в [Request](#request) для того щоб отримати дані з враховуванням цього фільтру.

### Формування query : {filter}

Фільтри поділяються на такі що можна комбінувати між собою, та такі що не можна, для прикладу `goods` і `taste` можна
комбінувати,
а `glassware` ні. Детальніше [тут](meta-info.md). Сервіс враховує це та для фільтрів що можна комбінувати він додає
нові, для фільтрів
де можна вибрати тільки один з варіантів, сервіс замінить вже існуючий фільтр на новий. Також на основі даних від
клієнта сервіс розуміє які фільтри зараз вибрані і для них встановлює `isActive` в `true`, а для інших `false`. Також
для фільтрів які вибрані зараз на стороні клієнта сервіс має інший алгоритм формування query, для таких фільтрів він
формує query яке виключає вибраний фільрт, але при цьому має усі інші вибрані фільтри.